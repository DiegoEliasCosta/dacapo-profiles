import pandas as pd
import os
import numpy as np
import xml.etree.ElementTree
import logging


# Logging Mambo-Jambo
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
console = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - [%(levelname)s] - %(message)s')
console.setFormatter(formatter)
logger.addHandler(console)


def find_all_threads(root):
    """
    Find all thread related nodes
    """
    threads = root.findall(".//node/[Parent='All threads']")
    return threads


def process_nodes(thread_name, node):
    """
    Main recursive function of this script.
    It searches for every node and flattens into a dictionary list
    :param thread_name:
        The thread name
    :param node:
        The Elementtree node object
    :return:
        A list of dictionaries, where each dictionary is a node in the original xml.
    """

    def is_self_time(node):
        """
        Check whether a node is a self-time node
        """
        return node.find('Name').text == 'Self time'

    if node is None or is_self_time(node):
        return []

    # Create a dictionary where the node elements will be saved into
    el = dict()
    el['Threads'] = thread_name
    el['Methods'] = node.find('Name').text

    el['Time'] = int(node.find('Time').text)
    el['Time (CPU)'] = int(node.find('Time-CPU').text)

    self_time_node = node.find("./node/[Name='Self time']")
    if self_time_node is None:
        # A node without self-time is a lead in the tree structure
        # Here, we assume that a leak has a self-time equivalent to the
        # attributed time in Time and Time-CPU
        el['Self Time'] = int(node.find('Time').text)
        el['Self Time (CPU)'] = int(node.find('Time-CPU').text)

    else:
        el['Self Time'] = int(self_time_node.find('Time').text)
        el['Self Time (CPU)'] = int(self_time_node.find('Time-CPU').text)

    result = list()
    result.append(el)

    children = node.findall('node')
    for c in children:
        # Recursive call
        result.extend(process_nodes(thread_name, c))

    return result


def profiles_parser(file, outputfile):
    """
    Main function of the script. Coordinates the parsing process.
    :param file: Input file
    :param outputfile: Output file (csv)
    :return:
    """
    root = xml.etree.ElementTree.parse(file).getroot()

    threads = find_all_threads(root)
    logger.info("%d threads found in this profile" % len(threads))

    # Create the dataframe where all parsed nodes will be saved into
    parsed_nodes = pd.DataFrame(columns=['Threads', 'Methods', 'Self Time', 'Self Time (CPU)', 'Time', 'Time (CPU)'])
    for t in threads:
        # For each thread 1) identify the thread name and 2) parse the tree
        thread_name = t.find('Name').text
        logger.info("Parsing the thread %s" % thread_name)

        thread_elements = process_nodes(thread_name, t)
        logger.info("Parsed %d nodes" % len(thread_elements))

        # Add to the DataFrame
        parsed_nodes = parsed_nodes.append(thread_elements, ignore_index=False)

    # Aggregate by summing all performance metrics - per Thread x Method
    logger.info("Grouping by Thread and Method and aggregating by SUMMING metrics")
    grouped_parsed_nodes = parsed_nodes.groupby(['Threads', 'Methods']).sum()

    # Save into disk
    logger.info("Saving into disk at %s" % outputfile)
    grouped_parsed_nodes.to_csv(outputfile)
    
    pass


def is_valid_file(parser, arg):
    if not os.path.exists(arg):
        parser.error("The file %s does not exist!" % arg)
    else:
        return open(arg, 'r')  # return an open file handle


if __name__ == '__main__':

    # Parse input parameters
    import argparse
    parser = argparse.ArgumentParser(description='Parse CPU profiles generated by JVisualVM.')

    parser.add_argument('input', type=str,
                        help='The input .xml file generated by VisualVM.')

    parser.add_argument('outputfile', type=argparse.FileType('w'),
                        help='The output file where a parsed .csv will be stored.')
    args = parser.parse_args()

    logger.info("Reading from %s" % args.input)
    logger.info("Writing at %s" % args.outputfile)

    profiles_parser(args.input, args.outputfile)
